apiVersion: batch/v1
kind: Job
metadata:
  name: backend-migration
  namespace: goormthon-5
  labels:
    app: backend
    component: migration
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,HookFailed
spec:
  ttlSecondsAfterFinished: 300  # Job은 완료 후 5분 뒤 자동 삭제
  backoffLimit: 3
  template:
    metadata:
      labels:
        app: backend
        component: migration
    spec:
      restartPolicy: Never
      containers:
      - name: migration
        image: 837126493345.dkr.ecr.ap-northeast-2.amazonaws.com/goormthon-5/backend:build-20
        command:
        - /bin/sh
        - -c
        - |
          set -euo pipefail

          python - <<'PY'
          import asyncio
          from sqlalchemy import text
          from sqlalchemy.ext.asyncio import create_async_engine

          from app.core.config import settings

          # Determine schema names
          schema = "app" if settings.environment == "production" else "public"
          version_table = f"{schema}.alembic_version" if schema != "public" else "alembic_version"
          probe_table = f"{schema}.heroes" if schema != "public" else "heroes"
          head_revision = "9b043473e2e7"

          async def main() -> None:
              engine = create_async_engine(settings.database_url, future=True)
              async with engine.begin() as conn:
                  # Ensure search_path includes target schema
                  # Param 바인딩은 search_path에서 허용되지 않으므로 literal로 설정
                  await conn.execute(text(f'SET search_path TO "{schema}", public'))

                  # Check whether alembic_version table exists
                  has_version_table = (
                      await conn.execute(text("SELECT to_regclass(:name)"), {"name": version_table})
                  ).scalar()

                  if has_version_table:
                      # Check if version row already present
                      version_row = (
                          await conn.execute(
                              text("SELECT version_num FROM " + version_table + " LIMIT 1")
                          )
                      ).scalar()

                      if version_row:
                          return

                      has_probe_table = (
                          await conn.execute(text("SELECT to_regclass(:name)"), {"name": probe_table})
                      ).scalar()

                      if has_probe_table:
                          print("Found existing schema with empty alembic_version; stamping to head.")
                          await conn.execute(
                              text(
                                  "INSERT INTO "
                                  + version_table
                                  + " (version_num) VALUES (:rev) ON CONFLICT DO NOTHING"
                              ),
                              {"rev": head_revision},
                          )
                          return

                  # If tables exist but version table is missing, stamp to head once
                  has_probe_table = (
                      await conn.execute(text("SELECT to_regclass(:name)"), {"name": probe_table})
                  ).scalar()

                  if has_probe_table:
                      print("Found existing schema without alembic_version; stamping to head.")
                      await conn.execute(text(f'CREATE SCHEMA IF NOT EXISTS "{schema}"'))
                      await conn.execute(
                          text(
                              f"CREATE TABLE IF NOT EXISTS {version_table} ("
                              "version_num VARCHAR(32) NOT NULL PRIMARY KEY)"
                          )
                      )
                      await conn.execute(
                          text(
                              "INSERT INTO "
                              + version_table
                              + " (version_num) VALUES (:rev) ON CONFLICT DO NOTHING"
                          ),
                          {"rev": head_revision},
                      )
                  else:
                      print("No existing schema detected; running migrations fresh.")

              await engine.dispose()

          asyncio.run(main())
          PY

          alembic upgrade head
        env:
        - name: ENVIRONMENT
          value: "production"
        - name: DB_HOST
          value: "postgres.goormthon-5.svc.cluster.local"
        - name: DB_PORT
          value: "5432"
        - name: DB_USER
          value: "postgres"
        - name: DB_PASSWORD
          value: "postgres123"
        - name: DB_NAME
          value: "wadeulwadeul_db"
        - name: DB_POOL_SIZE
          value: "10"
        - name: DB_MAX_OVERFLOW
          value: "20"
        - name: DB_POOL_PRE_PING
          value: "true"
        - name: DB_ECHO
          value: "false"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
